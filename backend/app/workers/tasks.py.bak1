import os
import requests
from datetime import datetime
from .celery_app import celery_app
from app.adapters import maxkb
import asyncio



# å…¥å£ä»»åŠ¡ï¼šä» WebDAV å–æ–‡ä»¶ã€å…¥åº“ï¼Œç„¶åæŠ•é€’åˆ° embed
@celery_app.task(name="app.workers.tasks.ingest_file", queue="ingest")
def ingest_file(path: str):
    # TODO: è¿™é‡Œåº”è¯¥å…ˆä»WebDAVä¸‹è½½æ–‡ä»¶å†…å®¹ï¼Œç„¶åå†ä¼ é€’ç»™embed_and_index
    # ç›®å‰è¿™ä¸ªä»»åŠ¡å¯èƒ½ä¸è¢«ä½¿ç”¨ï¼Œå»ºè®®æš‚æ—¶è¿”å›æˆåŠŸ
    print(f"ingest_file called with path: {path}")
    return {"ok": True, "message": "ingest_file not implemented yet"}


@celery_app.task(name="app.workers.tasks.embed_and_index", queue="embed")
def embed_and_index(text: str, meta: dict = None):
    if meta is None:
        meta = {}
    
    # æ·»åŠ è¯¦ç»†çš„è°ƒè¯•ä¿¡æ¯
    print(f"ğŸ” embed_and_index æ”¶åˆ°å‚æ•°:")
    print(f"  text ç±»å‹: {type(text)}")
    print(f"  text é•¿åº¦: {len(text) if isinstance(text, str) else 'N/A'}")
    print(f"  meta å†…å®¹: {meta}")
    
    # MaxKB é…ç½®ï¼ˆåŸºäºæŠ“åŒ…ä¿¡æ¯ï¼‰
    maxkb_base_url = "https://kb.kmchat.cloud"
    maxkb_api_key = os.getenv("MAXKB_API_KEY", "")
    # ä»æŠ“åŒ…ä¸­è·å–çš„çŸ¥è¯†åº“ ID
    maxkb_knowledge_id = "01992749-c3ee-7c80-bdb1-8752f7ed8d95"
    
    if not maxkb_api_key:
        print("MaxKB API Key æœªé…ç½®ï¼Œè·³è¿‡åŒæ­¥")
        return {"ok": True, "skipped": "MaxKB API Key not configured"}
    
    # æ„é€ æ–‡æ¡£æ•°æ®
    if isinstance(meta, dict):
        title = meta.get('title', 'æœªçŸ¥æ–‡æ¡£')
        source_uri = meta.get('source_uri', 'æœªçŸ¥æ¥æº')
    else:
        title = 'æœªçŸ¥æ–‡æ¡£'
        source_uri = str(meta) if meta else 'æœªçŸ¥æ¥æº'
   
    try:
        headers = {
            "Authorization": f"Bearer {maxkb_api_key}",
            "Content-Type": "application/json"
        }
        
        # åŸºäºæ—¥å¿—ç»“æœï¼Œç›´æ¥ä½¿ç”¨æœ‰æ•ˆçš„ç«¯ç‚¹
        effective_endpoints = [
            {
                "url": f"{maxkb_base_url}/api/knowledge/{maxkb_knowledge_id}/document/",
                "method": "POST",
                "payload": {
                    "name": title,
                    "content": text,
                    "type": "text",
                    "meta": {
                        "source_uri": source_uri,
                        "sync_from": "pkb"
                    }
                }
            },
            {
                "url": f"{maxkb_base_url}/api/dataset/{maxkb_knowledge_id}/document/",
                "method": "POST", 
                "payload": {
                    "name": title,
                    "content": text,
                    "type": "text"
                }
            }
        ]
        
        for endpoint_config in effective_endpoints:
            try:
                url = endpoint_config["url"]
                payload = endpoint_config["payload"]
                
                print(f"ğŸ“¤ å°è¯•æœ‰æ•ˆç«¯ç‚¹:")
                print(f"  URL: {url}")
                print(f"  æ ‡é¢˜: {title}")
                print(f"  è¯·æ±‚ä½“: {payload}")
                
                response = requests.post(url, json=payload, headers=headers, timeout=30)
                
                print(f"ğŸ“¥ MaxKB API å“åº”:")
                print(f"  çŠ¶æ€ç : {response.status_code}")
                print(f"  å“åº”å¤´: {dict(response.headers)}")
                print(f"  å“åº”å†…å®¹: {response.text}")
                print(f"  å“åº”é•¿åº¦: {len(response.text)}")
                
                if response.status_code == 200:
                    # æ£€æŸ¥å“åº”å†…å®¹
                    if response.text.strip():  # æœ‰å“åº”å†…å®¹
                        try:
                            response_data = response.json()
                            print(f"âœ… MaxKB çŸ¥è¯†åº“åŒæ­¥æˆåŠŸ: {title}")
                            return {
                                "ok": True, 
                                "maxkb_synced": True, 
                                "title": title,
                                "endpoint": url,
                                "response": response_data
                            }
                        except Exception as json_error:
                            print(f"JSON è§£æå¤±è´¥: {json_error}")
                            # å³ä½¿ JSON è§£æå¤±è´¥ï¼Œå¦‚æœçŠ¶æ€ç æ˜¯ 200ï¼Œä¹Ÿè®¤ä¸ºæˆåŠŸ
                            print(f"âœ… MaxKB çŸ¥è¯†åº“åŒæ­¥æˆåŠŸ (éJSONå“åº”): {title}")
                            return {
                                "ok": True, 
                                "maxkb_synced": True, 
                                "title": title,
                                "endpoint": url,
                                "response": response.text
                            }
                    else:  # ç©ºå“åº”
                        print(f"âœ… MaxKB çŸ¥è¯†åº“åŒæ­¥æˆåŠŸ (ç©ºå“åº”): {title}")
                        return {
                            "ok": True, 
                            "maxkb_synced": True, 
                            "title": title,
                            "endpoint": url,
                            "response": "empty_response"
                        }
                elif response.status_code == 201:
                    print(f"âœ… MaxKB çŸ¥è¯†åº“åˆ›å»ºæˆåŠŸ: {title}")
                    return {
                        "ok": True, 
                        "maxkb_synced": True, 
                        "title": title,
                        "endpoint": url,
                        "response": response.json() if response.text else "created"
                    }
                else:
                    print(f"âŒ ç«¯ç‚¹ {url} å¤±è´¥: {response.status_code}")
                    continue
                    
            except Exception as e:
                print(f"ç«¯ç‚¹ {url} å¼‚å¸¸: {e}")
                continue
        
        print(f"âš ï¸ æ‰€æœ‰ç«¯ç‚¹éƒ½å¤±è´¥")
        return {"ok": True, "maxkb_synced": False, "error": "æ‰€æœ‰ç«¯ç‚¹éƒ½å¤±è´¥"}
        
    except Exception as e:
        print(f"MaxKB çŸ¥è¯†åº“åŒæ­¥å¼‚å¸¸: {e}")
        import traceback
        traceback.print_exc()
        return {"ok": True, "maxkb_synced": False, "error": str(e)}
