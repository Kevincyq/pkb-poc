import { useState, useEffect } from 'react';
import { Row, Col, Button, message, Upload, Modal, Input, Drawer, Select, Slider, Tag, Progress, Tooltip } from 'antd';
import { SearchOutlined, PlusOutlined, FileTextOutlined, FilterOutlined, InfoCircleOutlined } from '@ant-design/icons';
import { useNavigate } from 'react-router-dom';
import { useQueryClient } from '@tanstack/react-query';
import MainLayout from '../../components/Layout/MainLayout';
import CollectionCard from '../../components/Collection/CollectionCard';
import AIInput from '../../components/AIInput/AIInput';
import UploadStatusCard, { type UploadFileStatus } from '../../components/Upload/UploadStatusCard';
import CreateCollectionModal from '../../components/Collection/CreateCollectionModal';
import SearchOverlay from '../../components/SearchOverlay';
import type { UploadProps } from 'antd';
import * as collectionService from '../../services/collectionManageService';
import { uploadFile, getProcessingStatus } from '../../services/uploadService';
import api from '../../services/api';


interface Category {
  id: string;
  name: string;
  color: string;
  content_count: number;
}

// ‰ΩøÁî®ÊúçÂä°‰∏≠ÂÆö‰πâÁöÑÁ±ªÂûã
type CustomCollection = collectionService.CustomCollection;

export default function Home() {
  const navigate = useNavigate();
  const queryClient = useQueryClient();
  const [categories, setCategories] = useState<Category[]>([]);
  const [customCollections, setCustomCollections] = useState<CustomCollection[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [renamingCollection, setRenamingCollection] = useState<CustomCollection | null>(null);
  const [newName, setNewName] = useState('');
  const [deletingCollection, setDeletingCollection] = useState<CustomCollection | null>(null);
  const [uploadFiles, setUploadFiles] = useState<UploadFileStatus[]>([]);
  const [uploadDrawerVisible, setUploadDrawerVisible] = useState(false);
  const [createCollectionModalVisible, setCreateCollectionModalVisible] = useState(false);
  
  // ÊâπÊ¨°Áä∂ÊÄÅÁÆ°ÁêÜ
  interface BatchStats {
    total: number;
    completed: number;
    failed: number;
    processing: number;
    overallProgress: number;
  }
  
  const getBatchStats = (): BatchStats => {
    const total = uploadFiles.length;
    const completed = uploadFiles.filter(f => f.status === 'completed').length;
    const failed = uploadFiles.filter(f => f.status === 'error').length;
    const processing = uploadFiles.filter(f => ['uploading', 'parsing', 'classifying'].includes(f.status)).length;
    
    // ËÆ°ÁÆóÊï¥‰ΩìËøõÂ∫¶
    const totalProgress = uploadFiles.reduce((sum, file) => sum + (file.progress || 0), 0);
    const overallProgress = total > 0 ? Math.round(totalProgress / total) : 0;
    
    return { total, completed, failed, processing, overallProgress };
  };
  
  // ÊêúÁ¥¢Áõ∏ÂÖ≥Áä∂ÊÄÅ
  const [searchModalVisible, setSearchModalVisible] = useState(false);
  const [searchOverlayVisible, setSearchOverlayVisible] = useState(false);
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<any[]>([]);
  const [searchLoading, setSearchLoading] = useState(false);
  const [searchFilters, setSearchFilters] = useState({
    categories: [] as string[],
    collections: [] as string[],
    modality: undefined as string | undefined,
    role: undefined as string | undefined,
    source: undefined as string | undefined,
    confidence: [0, 1] as [number, number]
  });

  useEffect(() => {
    loadData();
  }, []);

  const loadData = async () => {
    setIsLoading(true);
    setError(null);
    
    try {
      // Âπ∂Ë°åÂä†ËΩΩÊô∫ËÉΩÂêàÈõÜÂíåËá™Âª∫ÂêàÈõÜ
      const [categoriesResponse, customCollectionsData] = await Promise.all([
        api.get('/search/categories/stats'),
        collectionService.getCustomCollections()
      ]);
      
      // Â§ÑÁêÜÊô∫ËÉΩÂêàÈõÜÊï∞ÊçÆ
      const categoriesData = categoriesResponse.data;
      
      if (categoriesData.categories && Array.isArray(categoriesData.categories)) {
        // Áõ¥Êé•‰ΩøÁî®‰ºòÂåñÂêéÁöÑAPIËøîÂõûÁöÑÊï∞ÊçÆ
        setCategories(categoriesData.categories);
      } else {
        throw new Error('Invalid data format');
      }
      
      // Â§ÑÁêÜËá™Âª∫ÂêàÈõÜÊï∞ÊçÆ
      setCustomCollections(customCollectionsData);
      
    } catch (err: any) {
      console.error('Failed to load data:', err);
      
      // Êèê‰æõÊõ¥ÂèãÂ•ΩÁöÑÈîôËØØ‰ø°ÊÅØ
      let errorMessage = 'Âä†ËΩΩÂêàÈõÜÊï∞ÊçÆÂ§±Ë¥•';
      if (err.code === 'ERR_NETWORK' || err.message?.includes('Network Error')) {
        errorMessage = 'ÁΩëÁªúËøûÊé•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúËøûÊé•ÊàñÁ®çÂêéÈáçËØï';
      } else if (err.response?.status === 404) {
        errorMessage = 'ÊúçÂä°ÊöÇÊó∂‰∏çÂèØÁî®ÔºåËØ∑Á®çÂêéÈáçËØï';
      } else if (err.message?.includes('CORS')) {
        errorMessage = 'ÊúçÂä°ÈÖçÁΩÆÈóÆÈ¢òÔºåËØ∑ËÅîÁ≥ªÁÆ°ÁêÜÂëò';
      }
      
      setError(errorMessage);
      message.error(errorMessage);
      
      // ËÆæÁΩÆÈªòËÆ§ÁöÑÁ©∫Êï∞ÊçÆÔºåÈÅøÂÖçÈ°µÈù¢ÂÆåÂÖ®Êó†Ê≥ï‰ΩøÁî®
      setCategories([]);
      setCustomCollections([]);
    } finally {
      setIsLoading(false);
    }
  };

  // ‰øùÊåÅÂêëÂêéÂÖºÂÆπ
  const loadCategories = loadData;

  const handleSearch = () => {
    setSearchOverlayVisible(true);
  };

  const performSearch = async () => {
    const trimmedQuery = searchQuery.trim();
    if (!trimmedQuery) {
      message.warning('ËØ∑ËæìÂÖ•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç');
      return;
    }

    // È™åËØÅÊêúÁ¥¢Êü•ËØ¢ÈïøÂ∫¶
    if (trimmedQuery.length > 200) {
      message.warning('ÊêúÁ¥¢ÂÖ≥ÈîÆËØçËøáÈïøÔºåËØ∑Áº©Áü≠ÂêéÈáçËØï');
      return;
    }

    setSearchLoading(true);
    try {
      // ÊûÑÂª∫ÊêúÁ¥¢ÂèÇÊï∞
      const params = new URLSearchParams();
      params.append('q', trimmedQuery);
      params.append('top_k', '20');
      params.append('search_type', 'hybrid');

      // Ê∑ªÂä†ËøáÊª§Êù°‰ª∂
      if (searchFilters.categories.length > 0) {
        params.append('categories', searchFilters.categories.join(','));
      }
      if (searchFilters.collections.length > 0) {
        params.append('collections', searchFilters.collections.join(','));
      }
      if (searchFilters.modality) {
        params.append('modality', searchFilters.modality);
      }
      if (searchFilters.role) {
        params.append('role', searchFilters.role);
      }
      if (searchFilters.source) {
        params.append('source', searchFilters.source);
      }
      if (searchFilters.confidence[0] > 0) {
        params.append('confidence_min', searchFilters.confidence[0].toString());
      }
      if (searchFilters.confidence[1] < 1) {
        params.append('confidence_max', searchFilters.confidence[1].toString());
      }

      const response = await api.get(`/search?${params.toString()}`);
      
      // È™åËØÅÂìçÂ∫îÊï∞ÊçÆ
      if (!response.data) {
        throw new Error('ÊêúÁ¥¢ÂìçÂ∫îÊï∞ÊçÆ‰∏∫Á©∫');
      }
      
      const results = response.data.results || [];
      setSearchResults(results);
      
      if (results.length === 0) {
        message.info('Ê≤°ÊúâÊâæÂà∞Áõ∏ÂÖ≥ÂÜÖÂÆπÔºåËØ∑Â∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑÂÖ≥ÈîÆËØçÊàñË∞ÉÊï¥ËøáÊª§Êù°‰ª∂');
      } else {
        console.log(`üîç Search completed: found ${results.length} results`);
      }
    } catch (error: any) {
      console.error('Search error:', error);
      
      // Êõ¥ËØ¶ÁªÜÁöÑÈîôËØØÂ§ÑÁêÜ
      if (error.response?.status === 400) {
        message.error('ÊêúÁ¥¢ÂèÇÊï∞ÊúâËØØÔºåËØ∑Ê£ÄÊü•ËæìÂÖ•');
      } else if (error.response?.status === 500) {
        message.error('ÊúçÂä°Âô®ÈîôËØØÔºåËØ∑Á®çÂêéÈáçËØï');
      } else if (error.code === 'NETWORK_ERROR') {
        message.error('ÁΩëÁªúËøûÊé•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú');
      } else {
        message.error('ÊêúÁ¥¢Â§±Ë¥•ÔºåËØ∑ÈáçËØï');
      }
    } finally {
      setSearchLoading(false);
    }
  };

  const resetSearchFilters = () => {
    setSearchFilters({
      categories: [],
      collections: [],
      modality: undefined,
      role: undefined,
      source: undefined,
      confidence: [0, 1]
    });
  };

  const handleCreateCollection = () => {
    setCreateCollectionModalVisible(true);
  };

  const handleCreateCollectionSuccess = () => {
    setCreateCollectionModalVisible(false);
    loadData(); // ÈáçÊñ∞Âä†ËΩΩÊï∞ÊçÆ‰ª•ÊòæÁ§∫Êñ∞ÂàõÂª∫ÁöÑÂêàÈõÜ
  };

  const handleDeleteCollection = (collectionId: string) => {
    console.log('Attempting to delete collection:', collectionId);
    const collection = customCollections.find(c => c.id === collectionId);
    if (collection) {
      setDeletingCollection(collection);
    }
  };

  const confirmDelete = async () => {
    if (!deletingCollection) return;
    
    try {
      console.log('Calling delete API for collection:', deletingCollection.id);
      await collectionService.deleteCollection(deletingCollection.id);
      console.log('Delete API call successful, updating UI...');
      
      setCustomCollections(collections => 
        collections.filter(c => c.id !== deletingCollection.id)
      );
      
      setDeletingCollection(null);
      message.success('ÂêàÈõÜÂà†Èô§ÊàêÂäü');
    } catch (error: any) {
      console.error('Failed to delete collection:', error);
      message.error(`Âà†Èô§ÂêàÈõÜÂ§±Ë¥•: ${error.message || 'Êú™Áü•ÈîôËØØ'}`);
    }
  };

  const cancelDelete = () => {
    console.log('User cancelled delete operation');
    setDeletingCollection(null);
  };

  const handleRenameCollection = (collection: CustomCollection) => {
    setRenamingCollection(collection);
    setNewName(collection.name);
  };

  const handleRenameConfirm = async () => {
    if (renamingCollection && newName.trim()) {
      try {
        const updatedCollection = await collectionService.updateCollection(
          renamingCollection.id, 
          { name: newName.trim() }
        );
        
        setCustomCollections(collections =>
          collections.map(c =>
            c.id === renamingCollection.id ? updatedCollection : c
          )
        );
        
        setRenamingCollection(null);
        setNewName('');
        message.success('ÂêàÈõÜÈáçÂëΩÂêçÊàêÂäü');
      } catch (error: any) {
        console.error('Failed to rename collection:', error);
        message.error(`ÈáçÂëΩÂêçÂ§±Ë¥•: ${error.message || 'Êú™Áü•ÈîôËØØ'}`);
      }
    }
  };

  const handleAIInput = (value: string) => {
    console.log('AI Input:', value);
  };

  const handleCollectionClick = (_categoryId: string, categoryName: string) => {
    // Ê∏ÖÈô§Áõ∏ÂÖ≥ÁöÑÊü•ËØ¢ÁºìÂ≠òÔºåÁ°Æ‰øùÊòæÁ§∫ÊúÄÊñ∞Êï∞ÊçÆ
    queryClient.invalidateQueries({ 
      queryKey: ['categoryDocuments', categoryName] 
    });
    navigate(`/collection/${encodeURIComponent(categoryName)}`);
  };

  // Â§ÑÁêÜÂ§öÊñá‰ª∂‰∏ä‰º† - ÈáçÊûÑÁâàÊú¨
  const handleMultipleFileUpload = async (fileList: File[], batchId: string): Promise<void> => {
    console.log(`üöÄ ÂºÄÂßãÊâπÈáè‰∏ä‰º† ${fileList.length} ‰∏™Êñá‰ª∂ÔºåÊâπÊ¨°ID: ${batchId}`);
    
    // Êô∫ËÉΩÂπ∂ÂèëÊéßÂà∂ÔºöÊ†πÊçÆÊñá‰ª∂Â§ßÂ∞èÂÜ≥ÂÆöÂπ∂ÂèëÊï∞
    const getOptimalConcurrency = (files: File[]): number => {
      const totalSize = files.reduce((sum, file) => sum + (file.size || 0), 0);
      const avgSize = totalSize / files.length;
      
      // Ê†πÊçÆÂπ≥ÂùáÊñá‰ª∂Â§ßÂ∞èË∞ÉÊï¥Âπ∂ÂèëÊï∞
      if (avgSize < 1024 * 1024) {        // < 1MB: È´òÂπ∂Âèë
        return Math.min(5, files.length);
      } else if (avgSize < 10 * 1024 * 1024) {  // 1-10MB: ‰∏≠Âπ∂Âèë
        return Math.min(3, files.length);
      } else {                             // > 10MB: ‰ΩéÂπ∂Âèë
        return Math.min(2, files.length);
      }
    };
    
    const concurrentLimit = getOptimalConcurrency(fileList);
    console.log(`üìä Êô∫ËÉΩÂπ∂ÂèëÊéßÂà∂Ôºö${concurrentLimit} ‰∏™Âπ∂ÂèëÔºåÂπ≥ÂùáÊñá‰ª∂Â§ßÂ∞è: ${(fileList.reduce((sum, f) => sum + (f.size || 0), 0) / fileList.length / 1024 / 1024).toFixed(1)}MB`);
    
    let completedCount = 0;
    let failedCount = 0;
    
    // ÂàÜÊâπÂ§ÑÁêÜÊñá‰ª∂ÔºåÁ°Æ‰øùÁ®≥ÂÆöÊÄß
    for (let i = 0; i < fileList.length; i += concurrentLimit) {
      const batch = fileList.slice(i, i + concurrentLimit);
      console.log(`üì¶ Â§ÑÁêÜÊâπÊ¨° ${Math.floor(i / concurrentLimit) + 1}/${Math.ceil(fileList.length / concurrentLimit)}: ${batch.length} ‰∏™Êñá‰ª∂`);
      
      // Âπ∂ÂèëÂ§ÑÁêÜÂΩìÂâçÊâπÊ¨°
      const batchPromises = batch.map(async (file, index) => {
        const globalIndex = i + index;
        try {
          console.log(`‚¨ÜÔ∏è  [${globalIndex + 1}/${fileList.length}] ÂºÄÂßã‰∏ä‰º†: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)}MB)`);
          await handleFileUpload(file);
          completedCount++;
          console.log(`‚úÖ [${globalIndex + 1}/${fileList.length}] ‰∏ä‰º†ÂÆåÊàê: ${file.name}`);
        } catch (error) {
          failedCount++;
          console.error(`‚ùå [${globalIndex + 1}/${fileList.length}] ‰∏ä‰º†Â§±Ë¥•: ${file.name}`, error);
          
          // Á°Æ‰øùÂ§±Ë¥•ÁöÑÊñá‰ª∂‰πüÊúâÁä∂ÊÄÅÊòæÁ§∫
          const fileId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          setUploadFiles(prev => {
            // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÂ≠òÂú®Ëøô‰∏™Êñá‰ª∂ÁöÑËÆ∞ÂΩï
            const existingFile = prev.find(f => f.fileName === file.name && f.status === 'uploading');
            if (!existingFile) {
              // Â¶ÇÊûú‰∏çÂ≠òÂú®ÔºåÊ∑ªÂä†‰∏Ä‰∏™Â§±Ë¥•Áä∂ÊÄÅÁöÑËÆ∞ÂΩï
              const failedFileStatus: UploadFileStatus = {
                id: fileId,
                fileName: file.name,
                fileSize: file.size,
                status: 'error',
                progress: 0,
                errorMessage: error instanceof Error ? error.message : '‰∏ä‰º†Â§±Ë¥•',
                startTime: Date.now()
              };
              return [...prev, failedFileStatus];
            }
            return prev;
          });
        }
      });
      
      // Á≠âÂæÖÂΩìÂâçÊâπÊ¨°ÂÆåÊàê
      await Promise.all(batchPromises);
      
      // ÊâπÊ¨°Èó¥Áü≠ÊöÇÂª∂ËøüÔºåÈÅøÂÖçÊúçÂä°Âô®ÂéãÂäõËøáÂ§ß
      if (i + concurrentLimit < fileList.length) {
        await new Promise(resolve => setTimeout(resolve, 200));
      }
    }
    
    console.log(`üéâ ÊâπÈáè‰∏ä‰º†ÂÆåÊàêÔºÅÊàêÂäü: ${completedCount}, Â§±Ë¥•: ${failedCount}, ÊÄªËÆ°: ${fileList.length}`);
    
    // ÊòæÁ§∫ÂÆåÊàêÊèêÁ§∫
    if (failedCount === 0) {
      message.success(`ÊâπÈáè‰∏ä‰º†ÂÆåÊàêÔºÅÊàêÂäü‰∏ä‰º† ${completedCount} ‰∏™Êñá‰ª∂`);
    } else if (completedCount > 0) {
      message.warning(`ÊâπÈáè‰∏ä‰º†ÂÆåÊàêÔºÅÊàêÂäü ${completedCount} ‰∏™ÔºåÂ§±Ë¥• ${failedCount} ‰∏™`);
    } else {
      message.error(`ÊâπÈáè‰∏ä‰º†Â§±Ë¥•ÔºÅ${failedCount} ‰∏™Êñá‰ª∂‰∏ä‰º†Â§±Ë¥•`);
    }
  };

  // Â§ÑÁêÜÊñá‰ª∂‰∏ä‰º†
  const handleFileUpload = async (file: File) => {
    const fileId = `${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    // ÂàõÂª∫‰∏ä‰º†Êñá‰ª∂Áä∂ÊÄÅ
    const uploadFileStatus: UploadFileStatus = {
      id: fileId,
      fileName: file.name,
      fileSize: file.size,
      status: 'uploading',
      progress: 0,
      uploadProgress: 0,
      startTime: Date.now()
    };
    
    // Ê∑ªÂä†Âà∞‰∏ä‰º†ÂàóË°®Âπ∂ÊòæÁ§∫ÊäΩÂ±â
    setUploadFiles(prev => [...prev, uploadFileStatus]);
    setUploadDrawerVisible(true);
    
    try {
      // ‰ΩøÁî®Áªü‰∏ÄÁöÑ‰∏ä‰º†ÊúçÂä°ÔºåÊ∑ªÂä†ËøõÂ∫¶ÂõûË∞É
      const result = await uploadFile(file, (progressEvent) => {
        // ÂÆûÊó∂Êõ¥Êñ∞‰∏ä‰º†ËøõÂ∫¶
        setUploadFiles(prev => prev.map(f => 
          f.id === fileId ? { 
            ...f, 
            uploadProgress: progressEvent.progress,
            progress: Math.min(progressEvent.progress * 0.3, 30) // ‰∏ä‰º†Âç†ÊÄªËøõÂ∫¶ÁöÑ30%
          } : f
        ));
      });

      if (result.status === 'success') {
        // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫Ëß£Êûê‰∏≠
        setUploadFiles(prev => prev.map(f => 
          f.id === fileId ? { 
            ...f, 
            status: 'parsing', 
            progress: 30,
            contentId: result.content_id 
          } : f
        ));
        
        // ÂºÄÂßãËΩÆËØ¢Â§ÑÁêÜÁä∂ÊÄÅ
        pollProcessingStatus(result.content_id, fileId);
      } else {
        throw new Error(result.message || '‰∏ä‰º†Â§±Ë¥•');
      }
    } catch (error: any) {
      console.error('Upload error:', error);
      
      // Êõ¥Êñ∞Áä∂ÊÄÅ‰∏∫ÈîôËØØ
      setUploadFiles(prev => prev.map(f => 
        f.id === fileId ? { 
          ...f, 
          status: 'error', 
          errorMessage: error.message 
        } : f
      ));
    }
  };

  // ËΩÆËØ¢Â§ÑÁêÜÁä∂ÊÄÅ - Êô∫ËÉΩËΩÆËØ¢ÁâàÊú¨
  const pollProcessingStatus = (contentId: string, fileId: string) => {
    let pollCount = 0;
    
    // Ëé∑ÂèñÊñá‰ª∂‰ø°ÊÅØ‰ª•Ë∞ÉÊï¥ËΩÆËØ¢Á≠ñÁï•
    const fileInfo = uploadFiles.find(f => f.id === fileId);
    const isImage = fileInfo?.fileName.match(/\.(jpg|jpeg|png|gif|bmp|webp)$/i);
    const isLargeFile = (fileInfo?.fileSize || 0) > 10 * 1024 * 1024; // 10MB
    
    // Êô∫ËÉΩËΩÆËØ¢ÂèÇÊï∞
    const getPollingConfig = () => {
      if (isImage) {
        return { maxPolls: 20, interval: 1000 }; // ÂõæÁâáÔºö20ÁßíÔºå1ÁßíÈó¥Èöî
      } else if (isLargeFile) {
        return { maxPolls: 60, interval: 2000 }; // Â§ßÊñá‰ª∂Ôºö2ÂàÜÈíüÔºå2ÁßíÈó¥Èöî
      } else {
        return { maxPolls: 40, interval: 1500 }; // ÊôÆÈÄöÊñá‰ª∂Ôºö1ÂàÜÈíüÔºå1.5ÁßíÈó¥Èöî
      }
    };
    
    const { maxPolls, interval } = getPollingConfig();
    console.log(`üîÑ Starting smart polling for ${fileId}: maxPolls=${maxPolls}, interval=${interval}ms, isImage=${isImage}, isLarge=${isLargeFile}`);
    
    const pollInterval = setInterval(async () => {
      pollCount++;
      
      try {
        // ‰ΩøÁî®Áªü‰∏ÄÁöÑÁä∂ÊÄÅÊü•ËØ¢ÊúçÂä°
        const statusData = await getProcessingStatus(contentId);
        
        // Êõ¥Êñ∞Êñá‰ª∂Áä∂ÊÄÅ
        setUploadFiles(prev => prev.map(f => {
          if (f.id === fileId) {
            console.log(`üîÑ [${pollCount}/${maxPolls}] Updating file status for ${fileId}:`, {
              processing_status: statusData.processing_status,
              parsing_status: (statusData as any).parsing_status,
              classification_status: statusData.classification_status,
              show_classification: statusData.show_classification,
              categories_count: statusData.categories?.length || 0
            });
            
            // Êô∫ËÉΩÁä∂ÊÄÅÂà§Êñ≠ÈÄªËæë
            if (statusData.classification_status === 'completed' && statusData.show_classification) {
              // ÂàÜÁ±ªÂÆåÊàêÔºåÊòæÁ§∫ÁªìÊûú
              const categories = statusData.categories?.map((cat: any) => ({
                id: cat.id,
                name: cat.name,
                confidence: cat.confidence || 0.8,
                role: cat.role || 'primary_system',
                source: cat.source || 'ml',
                color: cat.role === 'primary_system' ? 'blue' : 
                       cat.role === 'secondary_system' ? 'cyan' : 
                       cat.role === 'user_rule' ? 'green' : 'default',
                is_system: cat.source === 'ml' || cat.source === 'heuristic'
              })) || [];
              
              console.log(`‚úÖ File ${fileId} classification completed with ${categories.length} categories`);
              
              return {
                ...f,
                status: 'completed',
                progress: 100,
                categories
              };
            } else {
              // Ê†πÊçÆËØ¶ÁªÜÁä∂ÊÄÅÊòæÁ§∫ËøõÂ∫¶ÂíåÁä∂ÊÄÅ
              let progress = 30;
              let status: 'uploading' | 'parsing' | 'classifying' = 'parsing';
              
              // Ê†πÊçÆËß£ÊûêÁä∂ÊÄÅ
              const parsingStatus = (statusData as any).parsing_status;
              if (parsingStatus === 'parsing') {
                progress = 35;
                status = 'parsing';
              } else if (parsingStatus === 'completed') {
                progress = 50;
                status = 'classifying';
                
                // Ê†πÊçÆÂàÜÁ±ªÁä∂ÊÄÅÁªÜÂåñËøõÂ∫¶
                if ((statusData.classification_status as any) === 'quick_processing') {
                  progress = 60;
                } else if (statusData.classification_status === 'quick_done') {
                  progress = 70;
                } else if ((statusData.classification_status as any) === 'ai_processing') {
                  progress = 85;
                }
              }
              
              console.log(`‚è≥ File ${fileId} processing: parsing=${parsingStatus}, classification=${statusData.classification_status}, progress=${progress}%`);
              
              return {
                ...f,
                status,
                progress
              };
            }
          }
          return f;
        }));
        
        // Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÂÅúÊ≠¢ËΩÆËØ¢
        if (statusData.classification_status === 'completed' && statusData.show_classification) {
          console.log(`üõë Stopping polling for ${fileId} - classification completed`);
          clearInterval(pollInterval);
          
          // Âà∑Êñ∞È°µÈù¢Êï∞ÊçÆ
          loadCategories();
        } else if (pollCount >= maxPolls) {
          // ËææÂà∞ÊúÄÂ§ßËΩÆËØ¢Ê¨°Êï∞Ôºå‰ΩÜ‰∏çÊ†áËÆ∞‰∏∫Â§±Ë¥•
          console.log(`‚è∞ Polling timeout for ${fileId}, but file may still be processing`);
          clearInterval(pollInterval);
          
          setUploadFiles(prev => prev.map(f => 
            f.id === fileId && f.status !== 'completed' ? { 
              ...f, 
              status: 'classifying',
              progress: 95,
              errorMessage: 'Â§ÑÁêÜ‰∏≠ÔºåËØ∑Á®çÂÄôÊàñÂà∑Êñ∞È°µÈù¢Êü•ÁúãÁªìÊûú' 
            } : f
          ));
        }
      } catch (error) {
        console.error(`‚ùå Status polling error for ${fileId}:`, error);
        
        // ÁΩëÁªúÈîôËØØ‰∏çÁ´ãÂç≥ÂÅúÊ≠¢ËΩÆËØ¢ÔºåÁªôÂá†Ê¨°ÈáçËØïÊú∫‰ºö
        if (pollCount < 5) {
          console.log(`üîÑ Retrying status check for ${fileId} (attempt ${pollCount})`);
          return; // ÁªßÁª≠ËΩÆËØ¢
        }
        
        clearInterval(pollInterval);
        
        // Êõ¥Êñ∞‰∏∫ÈîôËØØÁä∂ÊÄÅ
        setUploadFiles(prev => prev.map(f => 
          f.id === fileId ? { 
            ...f, 
            status: 'error', 
            errorMessage: 'Áä∂ÊÄÅÊü•ËØ¢Â§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢Êü•ÁúãÁªìÊûú' 
          } : f
        ));
      }
    }, interval); // ‰ΩøÁî®Êô∫ËÉΩÈó¥Èöî
  };

  // ÈáçËØïÊñá‰ª∂‰∏ä‰º†/Â§ÑÁêÜ
  const handleRetryFile = async (fileId: string) => {
    const fileToRetry = uploadFiles.find(f => f.id === fileId);
    if (!fileToRetry) {
      message.error('Êâæ‰∏çÂà∞Ë¶ÅÈáçËØïÁöÑÊñá‰ª∂');
      return;
    }

    console.log(`üîÑ Retrying file: ${fileToRetry.fileName}`);

    // Ê£ÄÊü•ÈîôËØØÁ±ªÂûãÔºåÂÜ≥ÂÆöÈáçËØïÁ≠ñÁï•
    const errorMessage = fileToRetry.errorMessage || '';
    
    if (errorMessage.includes('ÁΩëÁªú') || errorMessage.includes('ËøûÊé•') || errorMessage.includes('Ë∂ÖÊó∂')) {
      // ÁΩëÁªúÈîôËØØÔºöÈáçÊñ∞‰∏ä‰º†
      message.info(`Ê≠£Âú®ÈáçÊñ∞‰∏ä‰º†Êñá‰ª∂: ${fileToRetry.fileName}`);
      
      // ÈáçÁΩÆÊñá‰ª∂Áä∂ÊÄÅ
      setUploadFiles(prev => prev.map(f => 
        f.id === fileId ? {
          ...f,
          status: 'uploading',
          progress: 0,
          uploadProgress: 0,
          errorMessage: undefined,
          startTime: Date.now()
        } : f
      ));

      // ÈúÄË¶ÅÈáçÊñ∞Ëé∑ÂèñFileÂØπË±°ÔºåËøôÈáåÊöÇÊó∂ÊèêÁ§∫Áî®Êà∑ÈáçÊñ∞ÈÄâÊã©
      message.warning('ÁΩëÁªúÈîôËØØÂØºËá¥ÁöÑÂ§±Ë¥•ÈúÄË¶ÅÈáçÊñ∞ÈÄâÊã©Êñá‰ª∂‰∏ä‰º†');
      
    } else if (errorMessage.includes('Áä∂ÊÄÅÊü•ËØ¢') || errorMessage.includes('Â§ÑÁêÜ‰∏≠')) {
      // Áä∂ÊÄÅÊü•ËØ¢ÈîôËØØÔºöÈáçÊñ∞ËΩÆËØ¢
      message.info(`Ê≠£Âú®ÈáçÊñ∞Ê£ÄÊü•Êñá‰ª∂Áä∂ÊÄÅ: ${fileToRetry.fileName}`);
      
      if (fileToRetry.contentId) {
        // ÈáçÁΩÆÁä∂ÊÄÅÂπ∂ÈáçÊñ∞ÂºÄÂßãËΩÆËØ¢
        setUploadFiles(prev => prev.map(f => 
          f.id === fileId ? {
            ...f,
            status: 'classifying',
            progress: 30,
            errorMessage: undefined
          } : f
        ));
        
        // ÈáçÊñ∞ÂºÄÂßãËΩÆËØ¢
        pollProcessingStatus(fileToRetry.contentId, fileId);
      } else {
        message.error('Áº∫Â∞ëÂÜÖÂÆπIDÔºåÊó†Ê≥ïÈáçÊñ∞Ê£ÄÊü•Áä∂ÊÄÅ');
      }
      
    } else {
      // ÂÖ∂‰ªñÈîôËØØÔºöÊèêÁ§∫Áî®Êà∑ÈáçÊñ∞‰∏ä‰º†
      message.warning('ËØ•Êñá‰ª∂Â§ÑÁêÜÂ§±Ë¥•ÔºåÂª∫ËÆÆÈáçÊñ∞ÈÄâÊã©Êñá‰ª∂‰∏ä‰º†');
    }
  };

  // ÊâπÈáèÈáçËØïÂ§±Ë¥•Êñá‰ª∂
  const handleBatchRetry = () => {
    const failedFiles = uploadFiles.filter(f => f.status === 'error');
    
    if (failedFiles.length === 0) {
      message.info('Ê≤°ÊúâÂ§±Ë¥•ÁöÑÊñá‰ª∂ÈúÄË¶ÅÈáçËØï');
      return;
    }

    console.log(`üîÑ Batch retrying ${failedFiles.length} failed files`);
    
    // ÂàÜÁ±ªÈîôËØØÁ±ªÂûã
    const networkErrors = failedFiles.filter(f => 
      (f.errorMessage || '').includes('ÁΩëÁªú') || 
      (f.errorMessage || '').includes('ËøûÊé•') ||
      (f.errorMessage || '').includes('Ë∂ÖÊó∂')
    );
    
    const statusErrors = failedFiles.filter(f => 
      (f.errorMessage || '').includes('Áä∂ÊÄÅÊü•ËØ¢') || 
      (f.errorMessage || '').includes('Â§ÑÁêÜ‰∏≠')
    );

    // ÈáçËØïÁä∂ÊÄÅÊü•ËØ¢ÈîôËØØ
    if (statusErrors.length > 0) {
      message.info(`Ê≠£Âú®ÈáçÊñ∞Ê£ÄÊü• ${statusErrors.length} ‰∏™Êñá‰ª∂ÁöÑÁä∂ÊÄÅ`);
      
      statusErrors.forEach(file => {
        if (file.contentId) {
          setUploadFiles(prev => prev.map(f => 
            f.id === file.id ? {
              ...f,
              status: 'classifying',
              progress: 30,
              errorMessage: undefined
            } : f
          ));
          
          pollProcessingStatus(file.contentId, file.id);
        }
      });
    }

    // ÁΩëÁªúÈîôËØØÈúÄË¶ÅÈáçÊñ∞‰∏ä‰º†
    if (networkErrors.length > 0) {
      message.warning(`${networkErrors.length} ‰∏™Êñá‰ª∂Âõ†ÁΩëÁªúÈîôËØØÂ§±Ë¥•ÔºåÈúÄË¶ÅÈáçÊñ∞ÈÄâÊã©Êñá‰ª∂‰∏ä‰º†`);
    }
  };

  const uploadProps: UploadProps = {
    name: 'file',
    multiple: true,  // ÂêØÁî®Â§öÊñá‰ª∂ÈÄâÊã©
    showUploadList: false,
    beforeUpload: (file, fileList) => {
      // ÂÖ≥ÈîÆ‰øÆÂ§çÔºöÂè™Âú®Â§ÑÁêÜÁ¨¨‰∏Ä‰∏™Êñá‰ª∂Êó∂Ëß¶ÂèëÊâπÊ¨°Â§ÑÁêÜ
      const isFirstFile = fileList && fileList.indexOf(file) === 0;
      
      if (fileList && fileList.length > 1) {
        // üî• MVPÈôêÂà∂ÔºöÊõ¥‰øùÂÆàÁöÑÊñá‰ª∂ÈôêÂà∂
        if (isFirstFile) {
          // È™åËØÅÊñá‰ª∂Êï∞ÈáèÔºàMVPÔºöÊúÄÂ§ö5‰∏™Êñá‰ª∂Ôºâ
          if (fileList.length > 5) {
            message.error(`MVPÈò∂ÊÆµ‰∏ÄÊ¨°ÊúÄÂ§öÂè™ËÉΩ‰∏ä‰º†5‰∏™Êñá‰ª∂ÔºåÂΩìÂâçÈÄâÊã©‰∫Ü${fileList.length}‰∏™Êñá‰ª∂`);
            return false;
          }
          
          // È™åËØÅÂçï‰∏™Êñá‰ª∂Â§ßÂ∞èÔºàMVPÔºöÊØè‰∏™Êñá‰ª∂ÊúÄÂ§ß20MBÔºâ
          const maxSingleSize = 20 * 1024 * 1024; // 20MB
          const oversizedFiles = fileList.filter(f => (f.size || 0) > maxSingleSize);
          if (oversizedFiles.length > 0) {
            message.error(`MVPÈò∂ÊÆµÂçï‰∏™Êñá‰ª∂‰∏çËÉΩË∂ÖËøá20MBÔºå‰ª•‰∏ãÊñá‰ª∂Ë∂ÖÈôêÔºö${oversizedFiles.map(f => `${f.name}(${(f.size / 1024 / 1024).toFixed(1)}MB)`).join(', ')}`);
            return false;
          }
          
          // È™åËØÅÊÄªÊñá‰ª∂Â§ßÂ∞èÔºà‰øùÂÆà‰º∞ËÆ°Ôºö5‰∏™Êñá‰ª∂√ó20MB = 100MBÔºâ
          const totalSize = fileList.reduce((sum, f) => sum + (f.size || 0), 0);
          const maxTotalSize = 100 * 1024 * 1024; // 100MB
          if (totalSize > maxTotalSize) {
            message.error(`ÊâπÈáè‰∏ä‰º†ÊÄªÂ§ßÂ∞è‰∏çËÉΩË∂ÖËøá100MBÔºåÂΩìÂâçÔºö${(totalSize / 1024 / 1024).toFixed(1)}MB`);
            return false;
          }
          
          const batchId = `batch_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          console.log(`ÂºÄÂßãÊâπÊ¨°‰∏ä‰º†: ${batchId}, Êñá‰ª∂Êï∞Èáè: ${fileList.length}, ÊÄªÂ§ßÂ∞è: ${(totalSize / 1024 / 1024).toFixed(1)}MB`);
          
          // ÊòæÁ§∫‰∏ä‰º†ÊäΩÂ±â
          setUploadDrawerVisible(true);
          
          // Á´ãÂç≥Â§ÑÁêÜÊï¥‰∏™ÊâπÊ¨°
          handleMultipleFileUpload(fileList, batchId);
        }
        // ÂÖ∂‰ªñÊñá‰ª∂Áõ¥Êé•ËøîÂõûfalseÔºå‰∏çÂÅöÂ§ÑÁêÜ
      } else {
        // üî• MVPÈôêÂà∂ÔºöÂçïÊñá‰ª∂‰∏ä‰º†È™åËØÅ
        const maxSingleSize = 20 * 1024 * 1024; // 20MB
        if ((file.size || 0) > maxSingleSize) {
          message.error(`MVPÈò∂ÊÆµÂçï‰∏™Êñá‰ª∂‰∏çËÉΩË∂ÖËøá20MBÔºåÂΩìÂâçÊñá‰ª∂ ${file.name} Â§ßÂ∞è‰∏∫ ${(file.size / 1024 / 1024).toFixed(1)}MB`);
          return false;
        }
        
        // ÂçïÊñá‰ª∂Â§ÑÁêÜ
        console.log(`ÂºÄÂßãÂçïÊñá‰ª∂‰∏ä‰º†: ${file.name}`);
        handleFileUpload(file);
      }
      return false; // ÈòªÊ≠¢ÈªòËÆ§‰∏ä‰º†Ë°å‰∏∫
    },
    accept: '.txt,.md,.pdf,.jpg,.jpeg,.png,.gif,.bmp,.webp',  // ‚ö†Ô∏è OfficeÊñáÊ°£ÊöÇ‰∏çÊîØÊåÅ
  };

  // ÂØπÂêàÈõÜËøõË°åÊéíÂ∫è
  const sortedCategories = categories.sort((a, b) => {
    const order = ['ËÅåÂú∫ÂïÜÂä°', 'ÁßëÊäÄÂâçÊ≤ø', 'Â≠¶‰π†ÊàêÈïø', 'ÁîüÊ¥ªÁÇπÊª¥'];
    return order.indexOf(a.name) - order.indexOf(b.name);
  });

  // ÂØπËá™Âª∫ÂêàÈõÜÊåâÂàõÂª∫Êó∂Èó¥ÂÄíÂ∫èÊéíÂ∫è
  const sortedCustomCollections = [...customCollections].sort((a, b) => 
    new Date(b.created_at).getTime() - new Date(a.created_at).getTime()
  );

  return (
    <MainLayout>
      <div style={{
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '32px'
      }}>
        <h1 style={{
          margin: 0,
          fontSize: '18px',
          fontWeight: '500',
          color: '#1f1f1f',
          lineHeight: '28px'
        }}>
          ‰∏™‰∫∫Áü•ËØÜÂ∫ìÂä©ÁêÜ
        </h1>
        <div style={{
          display: 'flex',
          gap: '16px'
        }}>
          <Button
            type="text"
            icon={<SearchOutlined style={{ fontSize: '18px' }} />}
            onClick={handleSearch}
            style={{
              width: '32px',
              height: '32px',
              padding: 0,
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center'
            }}
          />
          {uploadFiles.length > 0 && (
            <Button
              type="text"
              icon={<FileTextOutlined style={{ fontSize: '18px' }} />}
              onClick={() => setUploadDrawerVisible(true)}
              style={{
                width: '32px',
                height: '32px',
                padding: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                position: 'relative'
              }}
            >
              {uploadFiles.filter(f => f.status !== 'completed').length > 0 && (
                <div style={{
                  position: 'absolute',
                  top: -2,
                  right: -2,
                  width: 8,
                  height: 8,
                  borderRadius: '50%',
                  backgroundColor: '#ff4d4f',
                  border: '1px solid #fff'
                }} />
              )}
            </Button>
          )}
          <Upload {...uploadProps}>
            <Button
              type="text"
              icon={<PlusOutlined style={{ fontSize: '18px' }} />}
              style={{
                width: '32px',
                height: '32px',
                padding: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center'
              }}
            />
          </Upload>
          <Tooltip 
            title={
              <div style={{ fontSize: '12px', lineHeight: '1.4' }}>
                <div style={{ fontWeight: 'bold', marginBottom: '4px', color: '#1890ff' }}>üìÅ Êñá‰ª∂‰∏ä‰º†ÈôêÂà∂ (MVPÁâàÊú¨)</div>
                <div style={{ marginBottom: '2px' }}>‚úÖ ÊîØÊåÅÊ†ºÂºèÔºö.txt, .md, .pdf</div>
                <div style={{ marginBottom: '2px' }}>‚úÖ ÊîØÊåÅÂõæÁâáÔºö.jpg, .jpeg, .png, .gif, .bmp, .webp</div>
                <div style={{ marginBottom: '2px' }}>‚ùå ÊöÇ‰∏çÊîØÊåÅÔºöOfficeÊñáÊ°£(.doc, .xls, .pptÁ≠â)</div>
                <div style={{ marginBottom: '2px' }}>üìè ÂçïÊñá‰ª∂Â§ßÂ∞èÔºö‚â§ 20MB</div>
                <div style={{ marginBottom: '2px' }}>üì¶ ÊâπÈáè‰∏ä‰º†Ôºö‚â§ 5‰∏™Êñá‰ª∂</div>
                <div style={{ color: '#52c41a' }}>üí° Â∞èÊñá‰ª∂Â§ÑÁêÜÊõ¥Âø´Ôºå‰ΩìÈ™åÊõ¥‰Ω≥</div>
              </div>
            }
            placement="bottomRight"
            overlayStyle={{ maxWidth: '280px' }}
          >
            <Button
              type="text"
              icon={<InfoCircleOutlined style={{ fontSize: '16px', color: '#1890ff' }} />}
              style={{
                width: '24px',
                height: '24px',
                padding: 0,
                display: 'flex',
                alignItems: 'center',
                justifyContent: 'center',
                marginLeft: '4px'
              }}
            />
          </Tooltip>
        </div>
      </div>

      <div style={{ padding: '0 0 120px' }}>
        {isLoading ? (
          <div style={{ 
            textAlign: 'center', 
            padding: '40px 0',
            color: '#666' 
          }}>
            Âä†ËΩΩ‰∏≠...
          </div>
        ) : error ? (
          <div style={{ 
            textAlign: 'center', 
            padding: '40px 0',
            color: '#ff4d4f' 
          }}>
            Âä†ËΩΩÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞ÈáçËØï
          </div>
        ) : (
          <Row gutter={[16, 16]}>
            {/* Create Card */}
            <Col span={4}>
              <CollectionCard
                title=""
                contentCount={0}
                isCreateCard
                onClick={handleCreateCollection}
              />
            </Col>
            
            {/* Custom Collections */}
            {sortedCustomCollections.map(collection => {
              console.log('Rendering collection:', collection.id, collection.name);
              return (
                <Col span={4} key={collection.id}>
                  <CollectionCard
                    title={collection.name}
                    contentCount={collection.content_count}
                    isCustomCollection
                    onDelete={() => {
                      console.log('Delete button clicked for collection:', collection.id, typeof collection.id);
                      handleDeleteCollection(collection.id);
                    }}
                    onRename={() => handleRenameCollection(collection)}
                    onClick={() => handleCollectionClick(collection.id, collection.name)}
                  />
                </Col>
              );
            })}
            
            {/* System Categories */}
            {sortedCategories.map(category => (
              <Col span={4} key={category.id}>
                <CollectionCard
                  title={category.name}
                  contentCount={category.content_count}
                  onClick={() => handleCollectionClick(category.id, category.name)}
                />
              </Col>
            ))}
          </Row>
        )}
      </div>

      <AIInput onSend={handleAIInput} />

      {/* ÈáçÂëΩÂêçÂØπËØùÊ°Ü */}
      <Modal
        title="ÈáçÂëΩÂêçÂêàÈõÜ"
        open={!!renamingCollection}
        onOk={handleRenameConfirm}
        onCancel={() => setRenamingCollection(null)}
      >
        <Input
          value={newName}
          onChange={e => setNewName(e.target.value)}
          placeholder="ËØ∑ËæìÂÖ•Êñ∞ÁöÑÂêàÈõÜÂêçÁß∞"
        />
      </Modal>

      {/* Âà†Èô§Á°ÆËÆ§ÂØπËØùÊ°Ü */}
      <Modal
        title="Á°ÆËÆ§Âà†Èô§"
        open={!!deletingCollection}
        onOk={confirmDelete}
        onCancel={cancelDelete}
        okText="Á°ÆÂÆöÂà†Èô§"
        cancelText="ÂèñÊ∂à"
        okType="danger"
      >
        <p>Á°ÆÂÆöË¶ÅÂà†Èô§ÂêàÈõÜ <strong>"{deletingCollection?.name}"</strong> ÂêóÔºü</p>
        <p>Âà†Èô§ÂêéÂêàÈõÜ‰∏≠ÁöÑÊñáÊ°£Â∞ÜÁßªÈô§ÂàÜÁ±ªÔºå‰ΩÜÊñáÊ°£Êú¨Ë∫´‰∏ç‰ºöË¢´Âà†Èô§„ÄÇ</p>
      </Modal>

      {/* Êñá‰ª∂‰∏ä‰º†Áä∂ÊÄÅÊäΩÂ±â */}
      <Drawer
        title={(
          <div style={{ display: 'flex', alignItems: 'center', gap: 8 }}>
            <FileTextOutlined />
            <span>Êñá‰ª∂‰∏ä‰º†Áä∂ÊÄÅ</span>
            {(() => {
              const stats = getBatchStats();
              if (stats.total > 0) {
                return (
                  <span style={{ 
                    fontSize: 12, 
                    color: '#666',
                    backgroundColor: '#f0f0f0',
                    padding: '2px 6px',
                    borderRadius: 10
                  }}>
                    {stats.processing > 0 ? `${stats.processing} ‰∏™Â§ÑÁêÜ‰∏≠` : 
                     stats.failed > 0 ? `${stats.completed}/${stats.total} ÂÆåÊàêÔºå${stats.failed} Â§±Ë¥•` :
                     `${stats.completed}/${stats.total} ÂÆåÊàê`}
                  </span>
                );
              }
              return null;
            })()}
          </div>
        )}
        placement="right"
        width={400}
        open={uploadDrawerVisible}
        onClose={() => setUploadDrawerVisible(false)}
        extra={
          uploadFiles.length > 0 && (
            <div style={{ display: 'flex', gap: 8 }}>
              {(() => {
                const stats = getBatchStats();
                const hasFailedFiles = stats.failed > 0;
                return hasFailedFiles ? (
                  <Button 
                    size="small" 
                    type="primary"
                    onClick={handleBatchRetry}
                  >
                    ÈáçËØïÂ§±Ë¥•
                  </Button>
                ) : null;
              })()}
              <Button 
                size="small" 
                onClick={() => {
                  setUploadFiles(prev => prev.filter(f => f.status !== 'completed'));
                  if (uploadFiles.filter(f => f.status !== 'completed').length === 0) {
                    setUploadDrawerVisible(false);
                  }
                }}
              >
                Ê∏ÖÈô§Â∑≤ÂÆåÊàê
              </Button>
            </div>
          )
        }
      >
        {uploadFiles.length === 0 ? (
          <div style={{ 
            textAlign: 'center', 
            padding: '40px 0',
            color: '#999' 
          }}>
            ÊöÇÊó†‰∏ä‰º†Êñá‰ª∂
          </div>
        ) : (
          <div>
            {/* ÊâπÊ¨°Êï¥‰ΩìËøõÂ∫¶ */}
            {(() => {
              const stats = getBatchStats();
              if (stats.total > 1) {
                return (
                  <div style={{ 
                    marginBottom: 16, 
                    padding: 12, 
                    backgroundColor: '#f8f9fa', 
                    borderRadius: 8,
                    border: '1px solid #e9ecef'
                  }}>
                    <div style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between', 
                      alignItems: 'center',
                      marginBottom: 8
                    }}>
                      <span style={{ fontWeight: 'bold', fontSize: 14 }}>
                        ÊâπÈáè‰∏ä‰º†ËøõÂ∫¶
                      </span>
                      <span style={{ fontSize: 12, color: '#666' }}>
                        {stats.completed + stats.failed}/{stats.total} ‰∏™Êñá‰ª∂
                      </span>
                    </div>
                    <Progress
                      percent={stats.overallProgress}
                      size="small"
                      status={stats.failed > 0 ? 'exception' : stats.processing > 0 ? 'active' : 'success'}
                      showInfo={true}
                      format={(percent) => `${percent}%`}
                    />
                    <div style={{ 
                      display: 'flex', 
                      justifyContent: 'space-between',
                      fontSize: 12,
                      color: '#666',
                      marginTop: 4
                    }}>
                      <span>‚úÖ ÊàêÂäü: {stats.completed}</span>
                      {stats.processing > 0 && <span>‚è≥ Â§ÑÁêÜ‰∏≠: {stats.processing}</span>}
                      {stats.failed > 0 && <span style={{ color: '#ff4d4f' }}>‚ùå Â§±Ë¥•: {stats.failed}</span>}
                    </div>
                  </div>
                );
              }
              return null;
            })()}
            
            {/* Âçï‰∏™Êñá‰ª∂Áä∂ÊÄÅÂàóË°® */}
            {uploadFiles.map(file => (
              <UploadStatusCard
                key={file.id}
                file={file}
                onViewCollection={(categoryName) => {
                  setUploadDrawerVisible(false);
                  // Ê∏ÖÈô§Áõ∏ÂÖ≥ÁöÑÊü•ËØ¢ÁºìÂ≠òÔºåÁ°Æ‰øùÊòæÁ§∫ÊúÄÊñ∞Êï∞ÊçÆ
                  queryClient.invalidateQueries({ 
                    queryKey: ['categoryDocuments', categoryName] 
                  });
                  navigate(`/collection/${encodeURIComponent(categoryName)}`);
                }}
                onRetry={(fileId) => {
                  handleRetryFile(fileId);
                }}
                onRemove={(fileId) => {
                  setUploadFiles(prev => prev.filter(f => f.id !== fileId));
                }}
              />
            ))}
          </div>
        )}
      </Drawer>

      {/* ÊêúÁ¥¢Ê®°ÊÄÅÊ°Ü */}
      <Modal
        title="Êô∫ËÉΩÊêúÁ¥¢"
        open={searchModalVisible}
        onCancel={() => setSearchModalVisible(false)}
        width={800}
        footer={[
          <Button key="reset" onClick={resetSearchFilters}>
            ÈáçÁΩÆËøáÊª§Âô®
          </Button>,
          <Button key="cancel" onClick={() => setSearchModalVisible(false)}>
            ÂèñÊ∂à
          </Button>,
          <Button key="search" type="primary" loading={searchLoading} onClick={performSearch}>
            ÊêúÁ¥¢
          </Button>
        ]}
      >
        <div style={{ marginBottom: '16px' }}>
          <Input.Search
            placeholder="ËæìÂÖ•ÊêúÁ¥¢ÂÖ≥ÈîÆËØç..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            onSearch={performSearch}
            enterButton="ÊêúÁ¥¢"
            size="large"
          />
        </div>

        {/* ËøáÊª§Âô® */}
        <div style={{ marginBottom: '16px', padding: '16px', background: '#f5f5f5', borderRadius: '8px' }}>
          <div style={{ display: 'flex', alignItems: 'center', marginBottom: '12px' }}>
            <FilterOutlined style={{ marginRight: '8px' }} />
            <span style={{ fontWeight: 'bold' }}>ÊêúÁ¥¢ËøáÊª§Âô®</span>
          </div>
          
          <Row gutter={[16, 16]}>
            <Col span={12}>
              <div style={{ marginBottom: '8px' }}>ÂàÜÁ±ªÁ≠õÈÄâÔºö</div>
              <Select
                mode="multiple"
                placeholder="ÈÄâÊã©ÂàÜÁ±ª"
                style={{ width: '100%' }}
                value={searchFilters.categories}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, categories: value }))}
                options={categories.map(cat => ({ label: cat.name, value: cat.name }))}
              />
            </Col>
            <Col span={12}>
              <div style={{ marginBottom: '8px' }}>ÂêàÈõÜÁ≠õÈÄâÔºö</div>
              <Select
                mode="multiple"
                placeholder="ÈÄâÊã©ÂêàÈõÜ"
                style={{ width: '100%' }}
                value={searchFilters.collections}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, collections: value }))}
                options={customCollections.map(col => ({ label: col.name, value: col.name }))}
              />
            </Col>
            <Col span={8}>
              <div style={{ marginBottom: '8px' }}>Êñá‰ª∂Á±ªÂûãÔºö</div>
              <Select
                placeholder="ÈÄâÊã©Á±ªÂûã"
                style={{ width: '100%' }}
                value={searchFilters.modality}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, modality: value }))}
                allowClear
                options={[
                  { label: 'ÊñáÊú¨', value: 'text' },
                  { label: 'ÂõæÁâá', value: 'image' },
                  { label: 'PDF', value: 'pdf' }
                ]}
              />
            </Col>
            <Col span={8}>
              <div style={{ marginBottom: '8px' }}>ÂàÜÁ±ªËßíËâ≤Ôºö</div>
              <Select
                placeholder="ÈÄâÊã©ËßíËâ≤"
                style={{ width: '100%' }}
                value={searchFilters.role}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, role: value }))}
                allowClear
                options={[
                  { label: '‰∏ªÂàÜÁ±ª', value: 'primary_system' },
                  { label: 'Ê¨°ÂàÜÁ±ª', value: 'secondary_system' },
                  { label: 'Áî®Êà∑ËßÑÂàô', value: 'user_rule' }
                ]}
              />
            </Col>
            <Col span={8}>
              <div style={{ marginBottom: '8px' }}>ÂàÜÁ±ªÊù•Ê∫êÔºö</div>
              <Select
                placeholder="ÈÄâÊã©Êù•Ê∫ê"
                style={{ width: '100%' }}
                value={searchFilters.source}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, source: value }))}
                allowClear
                options={[
                  { label: 'AIÂàÜÁ±ª', value: 'ml' },
                  { label: 'ËßÑÂàôÂàÜÁ±ª', value: 'heuristic' },
                  { label: 'Áî®Êà∑ËßÑÂàô', value: 'rule' }
                ]}
              />
            </Col>
            <Col span={24}>
              <div style={{ marginBottom: '8px' }}>ÁΩÆ‰ø°Â∫¶ËåÉÂõ¥Ôºö</div>
              <Slider
                range
                min={0}
                max={1}
                step={0.1}
                value={searchFilters.confidence}
                onChange={(value) => setSearchFilters(prev => ({ ...prev, confidence: value as [number, number] }))}
                marks={{
                  0: '0%',
                  0.5: '50%',
                  1: '100%'
                }}
              />
            </Col>
          </Row>
        </div>

        {/* ÊêúÁ¥¢ÁªìÊûú */}
        {searchResults.length > 0 && (
          <div>
            <div style={{ marginBottom: '12px', fontWeight: 'bold' }}>
              ÊêúÁ¥¢ÁªìÊûú ({searchResults.length} Êù°)
            </div>
            <div style={{ maxHeight: '400px', overflowY: 'auto' }}>
              {searchResults.map((result, index) => (
                <div
                  key={index}
                  style={{
                    padding: '12px',
                    border: '1px solid #e8e8e8',
                    borderRadius: '8px',
                    marginBottom: '8px',
                    cursor: 'pointer'
                  }}
                  onClick={() => {
                    // Ë∑≥ËΩ¨Âà∞ÊñáÊ°£ËØ¶ÊÉÖÊàñÊâÄÂ±ûÂêàÈõÜ
                    if (result.category_name) {
                      navigate(`/collection/${encodeURIComponent(result.category_name)}`);
                      setSearchModalVisible(false);
                    }
                  }}
                >
                  <div style={{ fontWeight: 'bold', marginBottom: '4px' }}>
                    {result.title}
                  </div>
                  <div style={{ fontSize: '12px', color: '#666', marginBottom: '8px' }}>
                    {result.text?.substring(0, 150)}...
                  </div>
                  <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                    {result.category_name && (
                      <Tag color="blue">üìÅ {result.category_name}</Tag>
                    )}
                    <Tag color="green">üìä {Math.round((result.score || 0) * 100)}%</Tag>
                    <Tag color="orange">üìÖ {result.created_at?.split('T')[0]}</Tag>
                  </div>
                </div>
              ))}
            </div>
          </div>
        )}
      </Modal>

      {/* ÂàõÂª∫ÂêàÈõÜÊ®°ÊÄÅÊ°Ü */}
      <CreateCollectionModal
        open={createCollectionModalVisible}
        onCancel={() => setCreateCollectionModalVisible(false)}
        onSuccess={handleCreateCollectionSuccess}
      />

      {/* ÊêúÁ¥¢Ë¶ÜÁõñÂ±Ç */}
      <SearchOverlay
        visible={searchOverlayVisible}
        onClose={() => setSearchOverlayVisible(false)}
      />
    </MainLayout>
  );
}